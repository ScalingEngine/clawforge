---
phase: 09-config-layer-tool-schema-entrypoint-foundation
plan: 03
type: execute
wave: 2
depends_on:
  - 09-01
files_modified:
  - lib/ai/tools.js
  - lib/tools/create-job.js
autonomous: true
requirements:
  - TOOL-01
  - TOOL-03

must_haves:
  truths:
    - "create_job tool schema accepts an optional target_repo string parameter"
    - "When target_repo is provided, the tool validates it against allowed repos via resolveTargetRepo() before creating a job"
    - "When target_repo is unrecognized, the tool returns an error without creating a job"
    - "When target_repo resolves successfully, createJob() writes target.json sidecar to the job branch alongside job.md"
    - "When target_repo is omitted or undefined, no target.json is written and behavior is identical to v1.1"
  artifacts:
    - path: "lib/ai/tools.js"
      provides: "Extended create_job tool with target_repo parameter and validation"
      contains: "target_repo"
    - path: "lib/tools/create-job.js"
      provides: "Job creation with optional target.json sidecar write"
      contains: "target.json"
  key_links:
    - from: "lib/ai/tools.js"
      to: "lib/tools/repos.js"
      via: "import and call resolveTargetRepo()"
      pattern: "resolveTargetRepo"
    - from: "lib/ai/tools.js"
      to: "lib/tools/create-job.js"
      via: "passes targetRepo to createJob()"
      pattern: "createJob.*targetRepo"
    - from: "lib/tools/create-job.js"
      to: "GitHub Contents API"
      via: "PUT target.json to job branch"
      pattern: "target\\.json"
---

<objective>
Extend the create_job tool to accept an optional target_repo parameter, validate it against the allowed repos list, and write a target.json sidecar to the job branch when a target repo is specified.

Purpose: This is the core data threading — target_repo flows from agent input through validation and into the job branch as a sidecar file that downstream workflows (Phase 10) can consume. Without target_repo in the tool schema, the agent has no way to express "work on repo X".
Output: Updated tools.js with target_repo in schema + validation, updated create-job.js with target.json sidecar write.
</objective>

<execution_context>
@/Users/nwessel/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nwessel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-config-layer-tool-schema-entrypoint-foundation/09-RESEARCH.md
@.planning/phases/09-config-layer-tool-schema-entrypoint-foundation/09-01-SUMMARY.md
@lib/ai/tools.js
@lib/tools/create-job.js
@lib/tools/github.js
@lib/tools/repos.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add target_repo to create_job tool schema with validation</name>
  <files>
    lib/ai/tools.js
  </files>
  <action>
Modify `lib/ai/tools.js` to support target_repo:

1. **Add imports** at the top (after the existing imports):
```javascript
import { loadAllowedRepos, resolveTargetRepo } from '../tools/repos.js';
```

2. **Add target_repo to the tool schema** — inside the `z.object({})` for createJobTool, after `job_description`:
```javascript
target_repo: z.string().optional().describe(
  'Optional: target repository name or alias (e.g., "neurostory", "ns"). ' +
  'Must match an entry in the allowed repos list. ' +
  'If omitted, job runs against the default clawforge repo.'
),
```

3. **Add validation in the tool handler** — Update the destructured params to include `target_repo`. After the `enrichedDescription` block (after the prior context enrichment try/catch, around line 48), add validation:

```javascript
// Resolve target repo if specified
let resolvedTarget = null;
if (target_repo) {
  const repos = loadAllowedRepos();
  resolvedTarget = resolveTargetRepo(target_repo, repos);
  if (!resolvedTarget) {
    return JSON.stringify({
      success: false,
      error: `Target repo "${target_repo}" not recognized or not in allowed repos list. ` +
             `Available: ${repos.map(r => r.name).join(', ')}`,
    });
  }
}
```

4. **Pass resolvedTarget to createJob** — Update the createJob call to pass the target:
```javascript
const result = await createJob(enrichedDescription, { targetRepo: resolvedTarget });
```

5. **Include target info in the success response** — Update the return:
```javascript
return JSON.stringify({
  success: true,
  job_id: result.job_id,
  branch: result.branch,
  ...(resolvedTarget && { target_repo: `${resolvedTarget.owner}/${resolvedTarget.slug}` }),
});
```

**Important:** The destructured parameter in the tool function must change from `({ job_description }, config)` to `({ job_description, target_repo }, config)`.

**Pitfall avoidance:** Treat both `undefined` and falsy values of `target_repo` as "no target" — use `if (target_repo)` not `if (target_repo !== undefined)`. This handles Zod `.optional()` (which yields `undefined`) and any null that might slip through.
  </action>
  <verify>
    <automated>grep -c "target_repo" lib/ai/tools.js && grep -c "resolveTargetRepo" lib/ai/tools.js && grep -c "loadAllowedRepos" lib/ai/tools.js</automated>
    <manual>Verify: (1) target_repo in schema, (2) validation returns error for unrecognized repos, (3) resolvedTarget passed to createJob, (4) success response includes target_repo when present</manual>
  </verify>
  <done>create_job schema accepts optional target_repo. Handler validates against allowed repos via resolveTargetRepo(). Unrecognized repos return error without creating a job. Resolved target passed to createJob().</done>
</task>

<task type="auto">
  <name>Task 2: Extend createJob to accept targetRepo and write target.json sidecar</name>
  <files>
    lib/tools/create-job.js
  </files>
  <action>
Modify `lib/tools/create-job.js` to support optional targetRepo:

1. **Update function signature** — Change from `createJob(jobDescription)` to `createJob(jobDescription, options = {})`. Extract `targetRepo` from options:
```javascript
async function createJob(jobDescription, options = {}) {
  const { targetRepo } = options;
```

2. **Update JSDoc** to document the new parameter:
```javascript
/**
 * Create a new job branch with updated job.md and optional target.json sidecar
 * @param {string} jobDescription - The job description to write to job.md
 * @param {object} [options] - Optional parameters
 * @param {object} [options.targetRepo] - Resolved target repo { owner, slug } from REPOS.json
 * @returns {Promise<{job_id: string, branch: string}>} - Job ID and branch name
 */
```

3. **Add target.json sidecar write** — After the job.md write (step 3, after line 35), add a conditional write:

```javascript
  // 4. Write target.json sidecar if targeting a different repo (v1.2 cross-repo)
  if (targetRepo) {
    const targetPayload = {
      owner: targetRepo.owner,
      slug: targetRepo.slug,
      repo_url: `https://github.com/${targetRepo.owner}/${targetRepo.slug}.git`,
    };
    await githubApi(`/repos/${GH_OWNER}/${GH_REPO}/contents/logs/${jobId}/target.json`, {
      method: 'PUT',
      body: JSON.stringify({
        message: `job: ${jobId} — target ${targetRepo.slug}`,
        content: Buffer.from(JSON.stringify(targetPayload, null, 2)).toString('base64'),
        branch: branch,
      }),
    });
  }
```

**Key details:**
- Uses the same `githubApi()` helper and pattern as the job.md write (existing step 3)
- `target.json` is at a different path (`logs/{jobId}/target.json`) than `job.md` — no SHA conflict
- Both are new file creates on the branch (PUT with no sha field = create)
- When `targetRepo` is null/undefined, this block is skipped — backward compatible
- Use `JSON.stringify(targetPayload, null, 2)` for readable JSON in the sidecar
  </action>
  <verify>
    <automated>grep -c "target.json" lib/tools/create-job.js && grep -c "targetRepo" lib/tools/create-job.js</automated>
    <manual>Verify: (1) createJob signature accepts options.targetRepo, (2) target.json write uses same githubApi pattern as job.md, (3) sidecar write is conditional on targetRepo being truthy, (4) no sidecar written when targetRepo is absent</manual>
  </verify>
  <done>createJob() accepts optional targetRepo. When provided, writes target.json sidecar with { owner, slug, repo_url } to the job branch alongside job.md. When absent, no sidecar is written — identical to v1.1 behavior.</done>
</task>

</tasks>

<verification>
1. `lib/ai/tools.js` — create_job schema includes `target_repo: z.string().optional()`
2. `lib/ai/tools.js` — Handler validates target_repo against allowed repos and returns error for unrecognized repos
3. `lib/ai/tools.js` — Resolved target is passed to createJob()
4. `lib/tools/create-job.js` — Accepts `options.targetRepo`, writes `target.json` when present
5. `lib/tools/create-job.js` — No change in behavior when targetRepo is absent (backward compatible)
6. No PATs or secrets in any new code — all auth via existing `githubApi()` which uses `GH_TOKEN` env var
</verification>

<success_criteria>
- Agent can call create_job with target_repo="neurostory" and it resolves + creates sidecar
- Agent calling create_job with target_repo="nonexistent" gets a clear error message
- Agent calling create_job without target_repo behaves exactly as v1.1
- target.json sidecar contains { owner, slug, repo_url } structure
</success_criteria>

<output>
After completion, create `.planning/phases/09-config-layer-tool-schema-entrypoint-foundation/09-03-SUMMARY.md`
</output>
