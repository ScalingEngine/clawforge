---
phase: 05-pipeline-hardening
plan: 02
type: execute
wave: 2
depends_on:
  - 05-01
files_modified:
  - .github/workflows/notify-job-failed.yml
  - templates/.github/workflows/run-job.yml
  - templates/.github/workflows/notify-job-failed.yml
  - templates/docker/job/entrypoint.sh
autonomous: true
requirements:
  - PIPE-02
  - PIPE-05

must_haves:
  truths:
    - "A failed job notification includes a failure_stage field set to docker_pull, auth, or claude"
    - "A failed job notification includes a log excerpt from the relevant stage"
    - "notify-job-failed.yml reads claude-output.jsonl (not .json)"
    - "templates/.github/workflows/run-job.yml is byte-for-byte identical to .github/workflows/run-job.yml"
    - "templates/.github/workflows/notify-job-failed.yml is byte-for-byte identical to .github/workflows/notify-job-failed.yml"
    - "templates/docker/job/entrypoint.sh is byte-for-byte identical to docker/job/entrypoint.sh"
  artifacts:
    - path: ".github/workflows/notify-job-failed.yml"
      provides: "Failure stage detection and .jsonl file reference"
      contains: "FAILURE_STAGE"
    - path: "templates/.github/workflows/run-job.yml"
      provides: "Synced template of run-job workflow"
    - path: "templates/.github/workflows/notify-job-failed.yml"
      provides: "Synced template of notify-job-failed workflow"
    - path: "templates/docker/job/entrypoint.sh"
      provides: "Synced template of job entrypoint"
  key_links:
    - from: ".github/workflows/notify-job-failed.yml"
      to: "webhook payload"
      via: "failure_stage field in jq JSON payload sent to /api/github/webhook"
      pattern: "failure_stage"
    - from: ".github/workflows/notify-job-failed.yml"
      to: "logs/${JOB_ID}/claude-output.jsonl"
      via: "file read for log content"
      pattern: "claude-output\\.jsonl"
    - from: "templates/.github/workflows/run-job.yml"
      to: ".github/workflows/run-job.yml"
      via: "byte-for-byte copy"
    - from: "templates/.github/workflows/notify-job-failed.yml"
      to: ".github/workflows/notify-job-failed.yml"
      via: "byte-for-byte copy"
    - from: "templates/docker/job/entrypoint.sh"
      to: "docker/job/entrypoint.sh"
      via: "byte-for-byte copy"
---

<objective>
Add failure stage categorization to notify-job-failed.yml and sync all templates with live files.

Purpose: Operators need to know WHERE a job failed (docker pull, auth, or Claude execution) without reading full logs. Template sync ensures new ClawForge instances get all Phase 5 improvements.

Output: Updated `notify-job-failed.yml` with failure stage detection and log excerpt, plus three template files synced byte-for-byte with their live counterparts.
</objective>

<execution_context>
@/Users/nwessel/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nwessel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-pipeline-hardening/05-RESEARCH.md
@.planning/phases/05-pipeline-hardening/05-01-SUMMARY.md
@.github/workflows/notify-job-failed.yml
@docker/job/entrypoint.sh
@.github/workflows/run-job.yml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add failure stage detection and update file references in notify-job-failed.yml</name>
  <files>.github/workflows/notify-job-failed.yml</files>
  <action>
Edit `.github/workflows/notify-job-failed.yml` to add failure stage detection and update the output file reference from `.json` to `.jsonl`.

**1. Update file reference (PIPE-03 completion):**
Change lines 40-41 from `claude-output.json` to `claude-output.jsonl`:
```bash
if [ -f "logs/${JOB_ID}/claude-output.jsonl" ]; then
    CLAUDE_OUTPUT=$(head -c 4000 "logs/${JOB_ID}/claude-output.jsonl")
fi
```

Also update the comment on line 38 from `claude-output.json` to `claude-output.jsonl`.

**2. Add failure stage detection (PIPE-02):**
After the `CLAUDE_OUTPUT` block and before the `RUN_LOG` block (between the current lines 42 and 44), add failure stage detection using artifact presence as proxy:

```bash
# Detect failure stage from committed artifacts
# preflight.md exists → docker pulled, auth completed
# claude-output.jsonl non-empty → Claude at least started
FAILURE_STAGE="docker_pull"
if [ -f "logs/${JOB_ID}/preflight.md" ]; then
    FAILURE_STAGE="auth"
fi
if [ -f "logs/${JOB_ID}/claude-output.jsonl" ] && [ -s "logs/${JOB_ID}/claude-output.jsonl" ]; then
    FAILURE_STAGE="claude"
fi
```

**Note on stage detection logic:** The stages cascade upward. If `preflight.md` exists, docker ran successfully and auth at least started. If `claude-output.jsonl` exists and is non-empty, Claude at least started (meaning docker and auth both succeeded). The label reflects the LAST stage that was reached, which is where the failure occurred.

**Edge case — `FAILURE_STAGE="auth"`:** This means docker ran and preflight was written (so the container started), but Claude produced no output. This could be an auth failure in `gh auth setup-git`, or Claude itself failed to start. The label "auth" is a reasonable proxy — if Claude had started, there would be output.

**3. Add failure_stage to webhook payload:**
In the `jq -n` command that builds the JSON payload, add `failure_stage` as a new field. Add `--arg failure_stage "$FAILURE_STAGE"` to the jq arguments, and add `failure_stage: $failure_stage` to the JSON object:

```bash
jq -n \
  --arg job_id "$JOB_ID" \
  --arg branch "$BRANCH" \
  --arg status "$STATUS" \
  --arg failure_stage "$FAILURE_STAGE" \
  --arg job "$JOB_CONTENT" \
  --arg run_url "$RUN_URL" \
  --arg log "$LOG_CONTENT" \
  '{
    job_id: $job_id,
    branch: $branch,
    status: $status,
    failure_stage: $failure_stage,
    job: $job,
    run_url: $run_url,
    pr_url: "",
    changed_files: [],
    commit_message: "",
    log: $log,
    merge_result: ""
  }' > /tmp/payload.json
```

The Event Handler webhook endpoint (`/api/github/webhook`) will receive the new `failure_stage` field. It does not need changes to accept it — the jq payload is passed through as-is and any new fields are included in the notification context. If the Event Handler destructures specific fields, the new field will simply be available for future use.
  </action>
  <verify>
    <automated>grep -q "FAILURE_STAGE" .github/workflows/notify-job-failed.yml && grep -q "failure_stage" .github/workflows/notify-job-failed.yml && grep -q "claude-output.jsonl" .github/workflows/notify-job-failed.yml && ! grep -q "claude-output\.json[^l]" .github/workflows/notify-job-failed.yml && echo "PASS" || echo "FAIL"</automated>
    <manual>Review the failure stage detection logic to confirm correct artifact-based cascade (docker_pull -> auth -> claude)</manual>
  </verify>
  <done>
    - notify-job-failed.yml detects failure stage using artifact presence (preflight.md, claude-output.jsonl)
    - FAILURE_STAGE is set to one of: docker_pull, auth, claude
    - failure_stage field is included in the webhook payload
    - All references to claude-output use .jsonl extension
    - No remaining references to claude-output.json (without the l) in this file
  </done>
</task>

<task type="auto">
  <name>Task 2: Sync all modified files to templates (PIPE-05)</name>
  <files>templates/.github/workflows/run-job.yml, templates/.github/workflows/notify-job-failed.yml, templates/docker/job/entrypoint.sh</files>
  <action>
Copy the three live files modified during Phase 5 to their template counterparts using byte-for-byte copy:

```bash
cp docker/job/entrypoint.sh templates/docker/job/entrypoint.sh
cp .github/workflows/run-job.yml templates/.github/workflows/run-job.yml
cp .github/workflows/notify-job-failed.yml templates/.github/workflows/notify-job-failed.yml
```

Then verify each pair is identical:

```bash
diff docker/job/entrypoint.sh templates/docker/job/entrypoint.sh
diff .github/workflows/run-job.yml templates/.github/workflows/run-job.yml
diff .github/workflows/notify-job-failed.yml templates/.github/workflows/notify-job-failed.yml
```

All three `diff` commands must produce no output (identical files).

This is the established template sync pattern from prior phases — byte-for-byte copy eliminates drift completely. Do NOT manually edit template files; always copy from live.
  </action>
  <verify>
    <automated>diff docker/job/entrypoint.sh templates/docker/job/entrypoint.sh && diff .github/workflows/run-job.yml templates/.github/workflows/run-job.yml && diff .github/workflows/notify-job-failed.yml templates/.github/workflows/notify-job-failed.yml && echo "PASS" || echo "FAIL"</automated>
  </verify>
  <done>
    - templates/docker/job/entrypoint.sh is byte-for-byte identical to docker/job/entrypoint.sh
    - templates/.github/workflows/run-job.yml is byte-for-byte identical to .github/workflows/run-job.yml
    - templates/.github/workflows/notify-job-failed.yml is byte-for-byte identical to .github/workflows/notify-job-failed.yml
    - All Phase 5 changes are reflected in templates for new instance scaffolding
  </done>
</task>

</tasks>

<verification>
1. `grep "FAILURE_STAGE" .github/workflows/notify-job-failed.yml` — shows stage detection logic
2. `grep "failure_stage" .github/workflows/notify-job-failed.yml` — shows field in webhook payload
3. `grep "claude-output.jsonl" .github/workflows/notify-job-failed.yml` — confirms .jsonl reference
4. `diff docker/job/entrypoint.sh templates/docker/job/entrypoint.sh` — no output (identical)
5. `diff .github/workflows/run-job.yml templates/.github/workflows/run-job.yml` — no output (identical)
6. `diff .github/workflows/notify-job-failed.yml templates/.github/workflows/notify-job-failed.yml` — no output (identical)
</verification>

<success_criteria>
- notify-job-failed.yml has failure stage detection with three stages (docker_pull, auth, claude)
- failure_stage field is present in the webhook JSON payload
- All claude-output references in notify-job-failed.yml use .jsonl
- All three template files are byte-for-byte identical to their live counterparts
</success_criteria>

<output>
After completion, create `.planning/phases/05-pipeline-hardening/05-02-SUMMARY.md`
</output>
