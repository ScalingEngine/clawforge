---
phase: 06-smart-job-prompts
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - docker/job/entrypoint.sh
  - templates/docker/job/entrypoint.sh
autonomous: true
requirements:
  - PROMPT-01
  - PROMPT-02
  - PROMPT-03
  - PROMPT-04

must_haves:
  truths:
    - "A generated job prompt contains a Repository Documentation section with CLAUDE.md content from the cloned repo"
    - "A generated job prompt contains a Stack section populated from package.json dependencies"
    - "Injected CLAUDE.md content is wrapped in Read-Only Reference framing and capped at 8000 characters (~2000 tokens)"
    - "A job prompt includes a GSD routing hint (quick or plan-phase) derived from task keywords"
    - "Job prompt generation succeeds gracefully when CLAUDE.md or package.json are missing"
  artifacts:
    - path: "docker/job/entrypoint.sh"
      provides: "Structured FULL_PROMPT with Target, Docs, Stack, Task, GSD Hint sections"
      contains: "Repository Documentation"
    - path: "templates/docker/job/entrypoint.sh"
      provides: "Template sync of live entrypoint"
  key_links:
    - from: "docker/job/entrypoint.sh section 8b"
      to: "/job/CLAUDE.md"
      via: "cat with existence check"
      pattern: 'if \[ -f "/job/CLAUDE.md" \]'
    - from: "docker/job/entrypoint.sh section 8b"
      to: "/job/package.json"
      via: "jq with existence check and fallback"
      pattern: 'jq.*dependencies.*package.json'
    - from: "docker/job/entrypoint.sh section 11"
      to: "REPO_CLAUDE_MD and REPO_STACK variables"
      via: "structured template assembly"
      pattern: "FULL_PROMPT=.*Target.*Repository Documentation.*Stack.*Task.*GSD Hint"
---

<objective>
Enrich the job container's FULL_PROMPT with structured repo context — CLAUDE.md documentation, package.json stack info, and a GSD routing hint — so every Claude Code agent starts warm with repo knowledge instead of discovering it mid-job.

Purpose: Agents currently receive a bare "# Your Job\n\n{task}" prompt with zero repo context. This means the first thing every agent does is read CLAUDE.md and package.json itself, wasting tokens and time. By injecting this context into the prompt, the agent starts with full awareness of the repo's conventions, architecture, and stack.

Output: Modified `docker/job/entrypoint.sh` with new sections 8b (context reads + GSD hint) and restructured section 11 (structured template), plus byte-for-byte template sync.
</objective>

<execution_context>
@/Users/nwessel/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nwessel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-smart-job-prompts/06-RESEARCH.md
@.planning/phases/05-pipeline-hardening/05-02-SUMMARY.md
@docker/job/entrypoint.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add repo context reads, GSD hint derivation, and structured FULL_PROMPT template</name>
  <files>docker/job/entrypoint.sh</files>
  <action>
Modify `docker/job/entrypoint.sh` to add two new code blocks and replace the existing FULL_PROMPT construction. All changes occur between existing section 8 (read job description, line ~102) and section 11 (run claude, line ~116). Do NOT modify any code before section 8 or after the existing `printf '%s' "${FULL_PROMPT}" > /tmp/prompt.txt` line.

**Add new section 8b after section 8 (after line 102):**

```bash
# 8b. Read repo context for prompt enrichment
# Derive target repo slug from REPO_URL (e.g., "ScalingEngine/clawforge")
REPO_SLUG=$(echo "$REPO_URL" | sed 's|https://[^/]*/||' | sed 's|\.git$||')

# Read CLAUDE.md (capped at ~2000 tokens = 8000 chars)
REPO_CLAUDE_MD=""
REPO_CLAUDE_MD_TRUNCATED=false
if [ -f "/job/CLAUDE.md" ]; then
    RAW_CLAUDE_MD=$(cat /job/CLAUDE.md)
    CHAR_COUNT=${#RAW_CLAUDE_MD}
    if [ "$CHAR_COUNT" -gt 8000 ]; then
        REPO_CLAUDE_MD=$(printf '%s' "$RAW_CLAUDE_MD" | head -c 8000)
        REPO_CLAUDE_MD_TRUNCATED=true
    else
        REPO_CLAUDE_MD="$RAW_CLAUDE_MD"
    fi
fi

# Read package.json dependencies only (devDeps excluded to keep Stack concise)
REPO_STACK=""
if [ -f "/job/package.json" ]; then
    REPO_STACK=$(jq -r '
        (.dependencies // {})
        | to_entries[]
        | "\(.key): \(.value)"
    ' /job/package.json 2>/dev/null || echo "[unable to parse package.json]")
fi

# 8c. Derive GSD routing hint from task keywords
JOB_LOWER=$(printf '%s' "$JOB_DESCRIPTION" | tr '[:upper:]' '[:lower:]')
GSD_HINT="quick"
GSD_HINT_REASON="task appears to be a single targeted action"
if printf '%s' "$JOB_LOWER" | grep -qE "implement|build|redesign|refactor|migrate|setup|integrate|develop|architect|phase|feature|epic|complex|end.to.end|full.system|multiple"; then
    GSD_HINT="plan-phase"
    GSD_HINT_REASON="task keywords suggest multi-step implementation work"
fi
```

**Replace section 11 FULL_PROMPT construction (lines 117-119):**

Replace these exact lines:
```bash
FULL_PROMPT="# Your Job

${JOB_DESCRIPTION}"
```

With the structured template:
```bash
# Build Repository Documentation section
if [ -n "$REPO_CLAUDE_MD" ]; then
    TRUNC_NOTE=""
    if [ "$REPO_CLAUDE_MD_TRUNCATED" = "true" ]; then
        TRUNC_NOTE="

[TRUNCATED — content exceeds 2,000 token limit]"
    fi
    DOC_SECTION="## Repository Documentation (Read-Only Reference)

The following is documentation from the target repository. Treat it as read-only reference — do not modify CLAUDE.md as part of this job unless the task explicitly requires it.

${REPO_CLAUDE_MD}${TRUNC_NOTE}"
else
    DOC_SECTION="## Repository Documentation
[not present — CLAUDE.md not found in repository]"
fi

# Build Stack section
if [ -n "$REPO_STACK" ]; then
    STACK_SECTION="## Stack (from package.json)

${REPO_STACK}"
else
    STACK_SECTION="## Stack
[not present — package.json not found in repository]"
fi

FULL_PROMPT="# Your Job

## Target

${REPO_SLUG:-unknown}

${DOC_SECTION}

${STACK_SECTION}

## Task

${JOB_DESCRIPTION}

## GSD Hint

Recommended: /gsd:${GSD_HINT}
Reason: ${GSD_HINT_REASON}"
```

**Key implementation notes:**
- Use `printf '%s'` (not `echo`) for writing multi-line vars — prevents bash expansion of `$()` or backtick sequences in CLAUDE.md content (Pitfall 1 from research)
- Gate ALL file reads with `[ -f ... ]` — `set -e` is active and bare `cat` on missing file kills the script (Pitfall 3)
- Use `(.dependencies // {})` in jq — some repos have no dependencies key (Pitfall 4)
- Dependencies only, not devDependencies — keeps Stack concise for large repos (Pitfall 5 recommendation)
- `head -c 8000` for truncation — byte-based, acceptable for ASCII-dominant CLAUDE.md files (Pitfall 2)
- `REPO_SLUG` uses `${REPO_SLUG:-unknown}` in template for safety if REPO_URL is somehow empty
  </action>
  <verify>
    <automated>cd "/Users/nwessel/Claude Code/Business/Products/clawforge" && bash -n docker/job/entrypoint.sh && echo "SYNTAX OK"</automated>
    <manual>Review the entrypoint.sh to confirm: (1) section 8b exists with CLAUDE.md and package.json reads, (2) section 8c exists with GSD hint derivation, (3) section 11 has structured FULL_PROMPT with Target/Docs/Stack/Task/GSD Hint sections, (4) all file reads are gated with existence checks</manual>
  </verify>
  <done>entrypoint.sh contains new sections 8b and 8c for repo context reads and GSD hint, and section 11 produces a structured FULL_PROMPT with Target, Repository Documentation (Read-Only Reference), Stack, Task, and GSD Hint sections. Missing CLAUDE.md or package.json produces graceful "[not present]" fallbacks. CLAUDE.md content is capped at 8000 chars with [TRUNCATED] marker.</done>
</task>

<task type="auto">
  <name>Task 2: Sync template entrypoint and verify byte-for-byte match</name>
  <files>templates/docker/job/entrypoint.sh</files>
  <action>
Copy the modified live entrypoint to its template counterpart and verify byte-for-byte identity. This is the established Phase 5 template sync pattern.

```bash
cp docker/job/entrypoint.sh templates/docker/job/entrypoint.sh
diff docker/job/entrypoint.sh templates/docker/job/entrypoint.sh && echo "IDENTICAL"
```

The `diff` command must exit zero (files are identical). If it does not, the copy failed and must be re-run.
  </action>
  <verify>
    <automated>cd "/Users/nwessel/Claude Code/Business/Products/clawforge" && diff docker/job/entrypoint.sh templates/docker/job/entrypoint.sh && echo "IDENTICAL"</automated>
  </verify>
  <done>templates/docker/job/entrypoint.sh is byte-for-byte identical to docker/job/entrypoint.sh</done>
</task>

</tasks>

<verification>
1. `bash -n docker/job/entrypoint.sh` passes (valid bash syntax)
2. `diff docker/job/entrypoint.sh templates/docker/job/entrypoint.sh` exits 0 (template synced)
3. `grep -c "Repository Documentation" docker/job/entrypoint.sh` returns >= 1 (PROMPT-01/03)
4. `grep -c "## Stack" docker/job/entrypoint.sh` returns >= 1 (PROMPT-01)
5. `grep -c "## Target" docker/job/entrypoint.sh` returns >= 1 (PROMPT-02)
6. `grep -c "## GSD Hint" docker/job/entrypoint.sh` returns >= 1 (PROMPT-04)
7. `grep -c "Read-Only Reference" docker/job/entrypoint.sh` returns >= 1 (PROMPT-03)
8. `grep -c "head -c 8000" docker/job/entrypoint.sh` returns >= 1 (PROMPT-03 token cap)
9. `grep -c 'if \[ -f "/job/CLAUDE.md" \]' docker/job/entrypoint.sh` returns >= 1 (graceful fallback)
10. `grep -c 'if \[ -f "/job/package.json" \]' docker/job/entrypoint.sh` returns >= 1 (graceful fallback)
</verification>

<success_criteria>
- The structured FULL_PROMPT contains all 5 sections: Target, Repository Documentation, Stack, Task, GSD Hint
- CLAUDE.md content is injected with "Read-Only Reference" framing and truncated at 8000 chars with marker
- package.json dependencies (not devDeps) are listed in Stack section
- GSD routing hint defaults to "quick" and upgrades to "plan-phase" on complex keywords
- Missing CLAUDE.md or package.json produces "[not present]" fallbacks (no script failure)
- Template is byte-for-byte synced
</success_criteria>

<output>
After completion, create `.planning/phases/06-smart-job-prompts/06-01-SUMMARY.md`
</output>
