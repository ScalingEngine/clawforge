---
phase: 07-previous-job-context
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/db/schema.js
  - lib/db/job-outcomes.js
  - api/index.js
autonomous: true
requirements: [HIST-01, HIST-04]

must_haves:
  truths:
    - "A completed job webhook persists status, changed files, PR URL, and log summary to the job_outcomes table"
    - "Job outcome is stored with the originating thread_id from job_origins lookup"
    - "A webhook for a job without a job_origins row does not attempt to save an outcome"
    - "saveJobOutcome failure does not break the existing notification flow"
  artifacts:
    - path: "lib/db/schema.js"
      provides: "jobOutcomes table definition"
      contains: "jobOutcomes"
    - path: "lib/db/job-outcomes.js"
      provides: "saveJobOutcome and getLastMergedJobOutcome helpers"
      exports: ["saveJobOutcome", "getLastMergedJobOutcome"]
    - path: "api/index.js"
      provides: "saveJobOutcome call inside handleGithubWebhook"
      contains: "saveJobOutcome"
  key_links:
    - from: "api/index.js"
      to: "lib/db/job-outcomes.js"
      via: "import saveJobOutcome"
      pattern: "saveJobOutcome\\("
    - from: "lib/db/job-outcomes.js"
      to: "lib/db/schema.js"
      via: "import jobOutcomes table"
      pattern: "import.*jobOutcomes.*from.*schema"
    - from: "lib/db/job-outcomes.js"
      to: "lib/db/index.js"
      via: "import getDb singleton"
      pattern: "getDb\\(\\)"
---

<objective>
Create the job_outcomes persistence layer — schema, DB helpers, and webhook integration — so completed job data is stored and available for future thread-scoped lookups.

Purpose: Without persisting job outcomes, follow-up jobs in the same thread cannot know what happened previously. This plan creates the storage foundation that Plan 02 will query.
Output: `job_outcomes` Drizzle table, `saveJobOutcome()` / `getLastMergedJobOutcome()` helpers, webhook handler integration, and generated migration SQL.
</objective>

<execution_context>
@/Users/nwessel/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nwessel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-previous-job-context/07-RESEARCH.md
@lib/db/schema.js
@lib/db/job-origins.js
@lib/db/index.js
@api/index.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add jobOutcomes schema, DB helper module, and generate Drizzle migration</name>
  <files>lib/db/schema.js, lib/db/job-outcomes.js</files>
  <action>
1. In `lib/db/schema.js`, add the `jobOutcomes` table definition after the existing `jobOrigins` table (before `settings`). Use the exact same import pattern (`sqliteTable`, `text`, `integer` from `drizzle-orm/sqlite-core`):

```javascript
export const jobOutcomes = sqliteTable('job_outcomes', {
  id: text('id').primaryKey(),
  jobId: text('job_id').notNull(),
  threadId: text('thread_id').notNull(),
  status: text('status').notNull(),
  mergeResult: text('merge_result').notNull(),
  prUrl: text('pr_url').notNull().default(''),
  changedFiles: text('changed_files').notNull().default('[]'),
  logSummary: text('log_summary').notNull().default(''),
  createdAt: integer('created_at').notNull(),
});
```

2. Create `lib/db/job-outcomes.js` following the exact pattern of `lib/db/job-origins.js`:

- `saveJobOutcome({ jobId, threadId, status, mergeResult, prUrl, changedFiles, logSummary })`:
  - Import `randomUUID` from `crypto`, `eq`, `desc`, `and` from `drizzle-orm`, `getDb` from `./index.js`, `jobOutcomes` from `./schema.js`
  - Generate `id` via `randomUUID()`
  - `changedFiles` stored as `JSON.stringify(Array.isArray(changedFiles) ? changedFiles : [])`
  - `createdAt` is `Date.now()`
  - Use synchronous `.run()` (matches `job-origins.js` pattern)

- `getLastMergedJobOutcome(threadId)`:
  - Query `jobOutcomes` table filtered by BOTH `eq(jobOutcomes.threadId, threadId)` AND `eq(jobOutcomes.mergeResult, 'merged')` using `and()` from `drizzle-orm`
  - `orderBy(desc(jobOutcomes.createdAt))` + `.limit(1)` + `.get()`
  - Return result or `null` (use `?? null`)
  - This satisfies HIST-03 (filtering at query level) and HIST-04 (thread_id scoping)

3. Run `npm run db:generate` to produce the migration SQL file in `drizzle/`. Do NOT hand-write migration SQL.
  </action>
  <verify>
    <automated>cd "/Users/nwessel/Claude Code/Business/Products/clawforge" && node -e "const s = require('./lib/db/schema.js'); console.log('jobOutcomes:', !!s.jobOutcomes); const jo = require('./lib/db/job-outcomes.js'); console.log('saveJobOutcome:', typeof jo.saveJobOutcome); console.log('getLastMergedJobOutcome:', typeof jo.getLastMergedJobOutcome);" && ls drizzle/0002_*.sql</automated>
    <manual>Verify migration SQL file contains CREATE TABLE job_outcomes with all expected columns</manual>
  </verify>
  <done>jobOutcomes table defined in schema.js, job-outcomes.js exports saveJobOutcome and getLastMergedJobOutcome, Drizzle migration file exists in drizzle/</done>
</task>

<task type="auto">
  <name>Task 2: Wire saveJobOutcome into handleGithubWebhook</name>
  <files>api/index.js</files>
  <action>
1. Add import at top of `api/index.js`:
```javascript
import { saveJobOutcome } from '../lib/db/job-outcomes.js';
```

2. Inside `handleGithubWebhook`, AFTER the existing `const origin = getJobOrigin(jobId);` and INSIDE the `if (origin)` block, add the `saveJobOutcome` call BEFORE the existing `addToThread` and Slack notification logic. Wrap in try/catch so failures are non-fatal (matches the defensive pattern used for `saveJobOrigin` in `tools.js`):

```javascript
// Persist job outcome for future thread-scoped lookups
try {
  saveJobOutcome({
    jobId,
    threadId: origin.threadId,
    status: results.status,
    mergeResult: results.merge_result,
    prUrl: results.pr_url,
    changedFiles: results.changed_files,
    logSummary: message,  // message = await summarizeJob(results)
  });
} catch (err) {
  console.error('Failed to save job outcome:', err);
}
```

Place this AFTER `const origin = getJobOrigin(jobId);` and INSIDE the `if (origin) {` block, BEFORE the `addToThread` call. This ensures:
- Only jobs with a known origin (and therefore a thread_id) get persisted (guards against direct API jobs without threads)
- The summarized `message` is already available (computed above)
- Failure does not prevent the notification from being sent
  </action>
  <verify>
    <automated>cd "/Users/nwessel/Claude Code/Business/Products/clawforge" && grep -n "saveJobOutcome" api/index.js && grep -n "import.*job-outcomes" api/index.js</automated>
    <manual>Verify saveJobOutcome call is inside the if(origin) block, after summarizeJob but before addToThread</manual>
  </verify>
  <done>handleGithubWebhook persists job outcomes on webhook receipt. Save is wrapped in try/catch, gated on origin existence, and uses thread_id from job_origins lookup.</done>
</task>

</tasks>

<verification>
1. `lib/db/schema.js` exports `jobOutcomes` with columns: id, jobId, threadId, status, mergeResult, prUrl, changedFiles, logSummary, createdAt
2. `lib/db/job-outcomes.js` exports `saveJobOutcome()` and `getLastMergedJobOutcome()`
3. `getLastMergedJobOutcome` filters by both threadId AND mergeResult='merged' (HIST-03 + HIST-04)
4. `api/index.js` imports and calls `saveJobOutcome` inside `if (origin)` block with try/catch
5. Drizzle migration file exists in `drizzle/` directory
6. No existing functionality is broken — notification flow, Slack posting, and addToThread all still work
</verification>

<success_criteria>
- jobOutcomes table persists all required fields (HIST-01)
- Lookups scoped by thread_id (HIST-04)
- Query-level merge_result filter ensures only merged outcomes are returned (HIST-03)
- Webhook handler saves outcomes without blocking notifications
- Migration file generated by drizzle-kit, not hand-written
</success_criteria>

<output>
After completion, create `.planning/phases/07-previous-job-context/07-01-SUMMARY.md`
</output>
