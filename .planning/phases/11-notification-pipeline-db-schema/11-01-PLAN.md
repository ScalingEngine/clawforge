---
phase: 11-notification-pipeline-db-schema
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/db/schema.js
  - lib/db/job-outcomes.js
  - drizzle/0003_phase11_target_repo.sql
  - drizzle/meta/_journal.json
  - drizzle/meta/0003_snapshot.json
autonomous: true
requirements:
  - NOTIF-02

must_haves:
  truths:
    - "job_outcomes table has a nullable target_repo column in the SQLite schema"
    - "saveJobOutcome() accepts and persists targetRepo without silent field dropping"
    - "Migration file is generated via drizzle-kit (not hand-written) so the journal stays consistent"
    - "Existing rows with NULL target_repo are unaffected — backward compatible"
  artifacts:
    - path: "lib/db/schema.js"
      provides: "jobOutcomes table definition with targetRepo nullable column"
      contains: "targetRepo: text('target_repo')"
    - path: "lib/db/job-outcomes.js"
      provides: "saveJobOutcome() updated signature with targetRepo parameter"
      contains: "targetRepo"
    - path: "drizzle/0003_phase11_target_repo.sql"
      provides: "ALTER TABLE migration adding target_repo column"
      contains: "ALTER TABLE"
  key_links:
    - from: "lib/db/schema.js"
      to: "drizzle/0003_phase11_target_repo.sql"
      via: "npm run db:generate — drizzle-kit reads schema and produces migration"
      pattern: "ALTER TABLE.*job_outcomes.*ADD COLUMN.*target_repo"
    - from: "lib/db/job-outcomes.js"
      to: "lib/db/schema.js"
      via: "import { jobOutcomes } from './schema.js' — .values() must include targetRepo"
      pattern: "targetRepo.*null"
---

<objective>
Add nullable target_repo column to the job_outcomes SQLite table and update the saveJobOutcome() write function to persist it. This is the DB foundation for cross-repo job attribution.

Purpose: All other Phase 11 work (webhook handler, get_job_status overlay) depends on the DB schema change landing first so inserts don't fail at runtime.
Output: Updated schema.js with targetRepo column, generated Drizzle migration file, updated saveJobOutcome() that accepts and persists targetRepo.
</objective>

<execution_context>
@/Users/nwessel/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nwessel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-notification-pipeline-db-schema/11-RESEARCH.md
@lib/db/schema.js
@lib/db/job-outcomes.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add targetRepo column to schema and generate migration</name>
  <files>lib/db/schema.js</files>
  <action>
    In lib/db/schema.js, add a nullable targetRepo column to the jobOutcomes table definition. Place it after the prUrl field and before changedFiles:

    ```javascript
    targetRepo: text('target_repo'),  // nullable — no .notNull(), no .default() — null for same-repo jobs
    ```

    The full updated jobOutcomes definition becomes:
    ```javascript
    export const jobOutcomes = sqliteTable('job_outcomes', {
      id: text('id').primaryKey(),
      jobId: text('job_id').notNull(),
      threadId: text('thread_id').notNull(),
      status: text('status').notNull(),
      mergeResult: text('merge_result').notNull(),
      prUrl: text('pr_url').notNull().default(''),
      targetRepo: text('target_repo'),
      changedFiles: text('changed_files').notNull().default('[]'),
      logSummary: text('log_summary').notNull().default(''),
      createdAt: integer('created_at').notNull(),
    });
    ```

    After editing schema.js, run from the project root:
    ```bash
    npm run db:generate
    ```

    This produces drizzle/0003_phase11_target_repo.sql (the exact filename is auto-generated by drizzle-kit — confirm the new file exists in drizzle/ after running). The migration SQL will contain `ALTER TABLE job_outcomes ADD COLUMN target_repo text;`. Do NOT hand-write the SQL.

    CRITICAL: Do not modify lib/db/index.js — the existing migrate() call in initDatabase() already handles new ALTER TABLE migrations automatically.
  </action>
  <verify>
    <automated>ls "/Users/nwessel/Claude Code/Business/Products/clawforge/drizzle/" | grep "0003" && grep -n "targetRepo\|target_repo" "/Users/nwessel/Claude Code/Business/Products/clawforge/lib/db/schema.js"</automated>
    <manual>Verify drizzle/0003_*.sql exists and contains ALTER TABLE job_outcomes ADD COLUMN target_repo</manual>
  </verify>
  <done>drizzle/0003_*.sql exists containing ALTER TABLE job_outcomes ADD COLUMN target_repo text; and lib/db/schema.js shows targetRepo: text('target_repo') in the jobOutcomes table without .notNull() or .default()</done>
</task>

<task type="auto">
  <name>Task 2: Update saveJobOutcome() to persist targetRepo</name>
  <files>lib/db/job-outcomes.js</files>
  <action>
    In lib/db/job-outcomes.js, update saveJobOutcome() in two places:

    1. Add targetRepo to the JSDoc @param block (after prUrl):
    ```javascript
    * @param {string|null} [params.targetRepo] - Optional target repo slug (e.g. 'owner/repo'). Null for same-repo jobs.
    ```

    2. Add targetRepo to the function parameter destructuring:
    ```javascript
    export function saveJobOutcome({ jobId, threadId, status, mergeResult, prUrl, targetRepo, changedFiles, logSummary }) {
    ```

    3. Add targetRepo to the Drizzle .values() object (after prUrl):
    ```javascript
    prUrl: prUrl ?? '',
    targetRepo: targetRepo ?? null,  // nullable — explicit null, not undefined
    ```

    PITFALL: Drizzle .values() does NOT auto-map object properties. If targetRepo is omitted from .values(), the column is silently skipped and the insert will fail at runtime once the migration has run. Verify it appears in BOTH the destructuring and the .values() call.

    Do not change getLastMergedJobOutcome() — it intentionally filters mergeResult='merged' only, which correctly excludes cross-repo outcomes from prior job context enrichment (cross-repo outcomes are in a different repo and should not feed back as context).
  </action>
  <verify>
    <automated>grep -n "targetRepo" "/Users/nwessel/Claude Code/Business/Products/clawforge/lib/db/job-outcomes.js"</automated>
    <manual>Confirm targetRepo appears in: (1) function parameter destructuring, (2) .values() object with ?? null</manual>
  </verify>
  <done>saveJobOutcome() destructuring includes targetRepo, .values() includes `targetRepo: targetRepo ?? null`, and the function signature comment documents the new optional parameter</done>
</task>

</tasks>

<verification>
1. `npm run db:generate` was run and produced drizzle/0003_*.sql (not hand-written)
2. drizzle/meta/_journal.json now has 4 entries (idx 0-3)
3. lib/db/schema.js jobOutcomes has targetRepo: text('target_repo') — no .notNull(), no .default()
4. lib/db/job-outcomes.js saveJobOutcome() signature and .values() both include targetRepo
5. getLastMergedJobOutcome() is unchanged
</verification>

<success_criteria>
- drizzle/0003_*.sql file exists containing ALTER TABLE job_outcomes ADD COLUMN target_repo text;
- lib/db/schema.js jobOutcomes table includes targetRepo nullable column
- lib/db/job-outcomes.js saveJobOutcome() persists targetRepo via .values()
- No changes to lib/db/index.js (migration runs automatically at startup)
- npm run build (or equivalent lint check) passes without errors
</success_criteria>

<output>
After completion, create `.planning/phases/11-notification-pipeline-db-schema/11-01-SUMMARY.md`
</output>
