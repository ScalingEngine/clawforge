---
phase: 11-notification-pipeline-db-schema
plan: "02"
type: execute
wave: 2
depends_on:
  - "11-01"
files_modified:
  - api/index.js
autonomous: true
requirements:
  - NOTIF-01
  - NOTIF-03

must_haves:
  truths:
    - "A cross-repo job completion (status=cross_repo_pr_open) triggers a Slack/Telegram notification with the target repo PR URL"
    - "Notification message language distinguishes cross-repo ('PR open for review') from same-repo ('merged')"
    - "target_repo is extracted from the webhook payload and passed to saveJobOutcome()"
    - "Same-repo job notifications are unaffected by these changes"
    - "Telegram thread-origin routing is wired alongside the existing Slack thread-origin routing"
  artifacts:
    - path: "api/index.js"
      provides: "handleGithubWebhook() with target_repo passthrough and Telegram thread-origin routing"
      contains: "target_repo"
  key_links:
    - from: "templates/.github/workflows/notify-pr-complete.yml"
      to: "api/index.js handleGithubWebhook()"
      via: "POST /api/github/webhook with status=cross_repo_pr_open and target_repo in payload"
      pattern: "target_repo.*payload\\.target_repo"
    - from: "api/index.js handleGithubWebhook()"
      to: "lib/db/job-outcomes.js saveJobOutcome()"
      via: "saveJobOutcome({ ..., targetRepo: results.target_repo || null })"
      pattern: "targetRepo.*target_repo"
    - from: "api/index.js handleGithubWebhook()"
      to: "lib/tools/telegram.js sendMessage()"
      via: "origin.platform === 'telegram' branch calls sendMessage(botToken, threadId, message)"
      pattern: "platform.*telegram.*sendMessage"
---

<objective>
Update handleGithubWebhook() in api/index.js to correctly process the cross_repo_pr_open status: extract target_repo from the payload, pass it to saveJobOutcome(), and add Telegram thread-origin routing alongside the existing Slack routing.

Purpose: Closes the notification loop for cross-repo jobs — users receive Slack or Telegram replies in their originating thread with the correct target repo PR URL.
Output: Updated api/index.js where cross-repo completions persist target_repo to DB and notify via both Slack and Telegram thread-origin paths.
</objective>

<execution_context>
@/Users/nwessel/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nwessel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-notification-pipeline-db-schema/11-RESEARCH.md
@.planning/phases/11-notification-pipeline-db-schema/11-01-SUMMARY.md
@api/index.js
@lib/tools/telegram.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract target_repo from payload and pass to saveJobOutcome()</name>
  <files>api/index.js</files>
  <action>
    In api/index.js inside handleGithubWebhook(), make two changes:

    **Change 1 — Add target_repo to the results object** (after commit_message line):
    ```javascript
    const results = {
      job: payload.job || '',
      pr_url: payload.pr_url || payload.run_url || '',
      run_url: payload.run_url || '',
      status: payload.status || '',
      failure_stage: payload.failure_stage || '',
      merge_result: payload.merge_result || '',
      log: payload.log || '',
      changed_files: payload.changed_files || [],
      commit_message: payload.commit_message || '',
      target_repo: payload.target_repo || '',   // NEW: passthrough from Phase 10 payload
    };
    ```

    **Change 2 — Pass targetRepo to saveJobOutcome()** (inside the try block where saveJobOutcome is called):
    ```javascript
    saveJobOutcome({
      jobId,
      threadId: origin.threadId,
      status: results.status,
      mergeResult: results.merge_result,
      prUrl: results.pr_url,
      targetRepo: results.target_repo || null,   // NEW: nullable
      changedFiles: results.changed_files,
      logSummary: message,
    });
    ```

    The summarizeJob(results) call already receives the full results object including target_repo and status='cross_repo_pr_open'. The LLM will naturally produce "PR open for review" language from these signals — no system prompt change needed per STATE.md decision and research recommendation.

    Do NOT create a new route or a new code path for cross-repo vs same-repo outcomes. The existing flow handles both: saveJobOutcome is called for all job completions, addToThread is called for all, and then platform-specific notification follows.
  </action>
  <verify>
    <automated>grep -n "target_repo\|targetRepo" "/Users/nwessel/Claude Code/Business/Products/clawforge/api/index.js"</automated>
    <manual>Confirm target_repo appears in results object AND targetRepo appears in saveJobOutcome() call with || null</manual>
  </verify>
  <done>api/index.js results object includes target_repo field; saveJobOutcome() call passes targetRepo: results.target_repo || null</done>
</task>

<task type="auto">
  <name>Task 2: Add Telegram thread-origin routing for job completions</name>
  <files>api/index.js</files>
  <action>
    In api/index.js inside handleGithubWebhook(), after the existing Slack notification block (the `if (origin.platform === 'slack') { ... }` block), add a Telegram thread-origin routing block:

    ```javascript
    // Send to Telegram thread (thread-origin routing)
    if (origin.platform === 'telegram') {
      const { TELEGRAM_BOT_TOKEN } = process.env;
      if (TELEGRAM_BOT_TOKEN && origin.threadId) {
        try {
          const { sendMessage } = await import('../lib/tools/telegram.js');
          await sendMessage(TELEGRAM_BOT_TOKEN, origin.threadId, message);
          console.log(`Telegram notification sent for job ${jobId.slice(0, 8)}`);
        } catch (err) {
          console.error('Failed to send Telegram notification:', err);
        }
      }
    }
    ```

    Note on the import path: api/index.js already imports from `../lib/...` for other modules (e.g. `from '../lib/tools/create-job.js'`). Use the same relative path pattern. The dynamic import mirrors the existing Slack WebClient dynamic import pattern.

    IMPORTANT: The existing distributeNotification() subscription broadcast in lib/db/notifications.js is separate from thread-origin routing. Both will fire for Telegram-originated jobs: (1) the subscription broadcast fires via createNotification() already called above, and (2) this new thread-origin block sends directly to the originating chat. This dual-send is correct and intentional — subscriptions are for monitoring, thread-origin is for direct reply.

    Do NOT remove or alter the existing Slack routing block.
  </action>
  <verify>
    <automated>grep -n "telegram\|TELEGRAM_BOT_TOKEN\|sendMessage" "/Users/nwessel/Claude Code/Business/Products/clawforge/api/index.js"</automated>
    <manual>Confirm Telegram block appears after Slack block, uses dynamic import of sendMessage, and has try/catch error handling</manual>
  </verify>
  <done>api/index.js handleGithubWebhook() has both Slack and Telegram thread-origin notification blocks; each is guarded by platform check and token presence check with try/catch</done>
</task>

</tasks>

<verification>
1. api/index.js results object has target_repo: payload.target_repo || ''
2. saveJobOutcome() call includes targetRepo: results.target_repo || null
3. Telegram thread-origin block exists after Slack block — platform === 'telegram' guard, TELEGRAM_BOT_TOKEN check, sendMessage dynamic import, try/catch
4. Same-repo flow unchanged: Slack routing still works, saveJobOutcome still called, addToThread still called
5. No new routes created — /api/github/webhook handles all cases
</verification>

<success_criteria>
- Cross-repo webhook payload (status=cross_repo_pr_open) flows through: results extraction → summarizeJob → createNotification → saveJobOutcome (with targetRepo) → addToThread → platform-specific notification
- Telegram jobs get thread-origin reply via sendMessage()
- Slack jobs continue to use existing WebClient postMessage()
- target_repo value from payload persists to job_outcomes.target_repo column (Plan 01 migration required)
</success_criteria>

<output>
After completion, create `.planning/phases/11-notification-pipeline-db-schema/11-02-SUMMARY.md`
</output>
